-- Katy's Vampire Legends 2 Hub (LinoriaLib - Minimal & Safe)
-- violin-suzutsuki mirror | FULLY SAFE VERSION

local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

local Window = Library:CreateWindow({
    Title = 'Norlape\'s Hub ğŸ§›â€â™€ï¸',
    Center = true,
    AutoShow = true,
})

local Tabs = {
    Combat = Window:AddTab('Combat'),
    Visuals = Window:AddTab('Visuals'),
    Misc = Window:AddTab('Misc'),
    ['UI Settings'] = Window:AddTab('UI Settings'),
}

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TeleportService = game:GetService("TeleportService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local mouse = LocalPlayer:GetMouse()
mouse.Icon = "rbxasset://textures\\GunCursor.png"

-- Global variables
local hitboxEnabled = false
local showStatusIndicator = true
local statusDrawing = nil

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- ULTRA WIDE HITBOX (SAFE)
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local MegaGroup = Tabs.Combat:AddLeftGroupbox('ULTRA WIDE HITBOX')
MegaGroup:AddToggle('MegaHitboxEnabled', {Text = 'Enabled', Default = false})
MegaGroup:AddSlider('HitboxScale', {Text = 'Grid Scale', Default = 1.0, Min = 0.4, Max = 2.5, Rounding = 2, Suffix = 'Ã—'})

local baseGridOffsets = {}
local function addRingPoints(radius, count)
    if radius == 0 then table.insert(baseGridOffsets, Vector2.new(0,0)) return end
    for i = 0, count - 1 do
        local angle = (i / count) * math.pi * 2 + math.rad(22.5)
        table.insert(baseGridOffsets, Vector2.new(math.cos(angle)*radius, math.sin(angle)*radius))
    end
end

addRingPoints(0,1) addRingPoints(45,8) addRingPoints(100,12) addRingPoints(180,16) addRingPoints(260,8)
local extras = {Vector2.new(320,320),Vector2.new(-320,-320),Vector2.new(320,-320),Vector2.new(-320,320),Vector2.new(0,380),Vector2.new(0,-380),Vector2.new(380,0),Vector2.new(-380,0)}
for _,v in extras do table.insert(baseGridOffsets,v) end

local SUPER_RANGE = 4800
local function getJitter() return Vector2.new(math.random(-15,15), math.random(-15,15)) end

local HitDetection, AbilityHandler
pcall(function()
    HitDetection = require(ReplicatedStorage.ModuleScripts.TargetSystem.HitDetection)
    AbilityHandler = require(LocalPlayer.PlayerScripts.ModuleScripts.AbilityHandler)
end)

local oldHitscan = nil
local currentScale = 1.0

local function getScaledOffsets()
    local s = (Options.HitboxScale and Options.HitboxScale.Value) or 1
    local t = {}
    for _,o in baseGridOffsets do table.insert(t, o * s) end
    return t
end

local function hookedHitscan(self)
    if not hitboxEnabled or not HitDetection or not AbilityHandler then 
        return oldHitscan and oldHitscan(self) 
    end
    local cam = workspace.CurrentCamera 
    if not cam then return oldHitscan and oldHitscan(self) end
    local best, bestD = nil, math.huge
    local centerTh = 70 * currentScale
    local offs = getScaledOffsets()
    for _, offset in offs do
        local probe = Vector2.new(mouse.X, mouse.Y) + offset + getJitter()
        local vx,vy = cam.ViewportSize.X, cam.ViewportSize.Y
        probe = Vector2.new(math.clamp(probe.X, -vx*0.2, vx*1.2), math.clamp(probe.Y, -vy*0.2, vy*1.2))
        local ray = cam:ScreenPointToRay(probe.X, probe.Y)
        local dir = ray.Direction * SUPER_RANGE
        local p = RaycastParams.new()
        p.FilterDescendantsInstances = {LocalPlayer.Character or workspace}
        p.FilterType = Enum.RaycastFilterType.Exclude
        p.IgnoreWater = true
        local res = workspace:Raycast(ray.Origin, dir, p)
        if res then
            local mdl = res.Instance:FindFirstAncestorWhichIsA("Model")
            if mdl and mdl:FindFirstChildWhichIsA("Humanoid") then
                local tp = Players:GetPlayerFromCharacter(mdl)
                if tp and tp ~= LocalPlayer and AbilityHandler.canBeAffected(tp, self._name) then
                    local d = (res.Position - ray.Origin).Magnitude
                    if d < bestD then bestD = d best = mdl end
                    if (offset + getJitter()).Magnitude < centerTh then return mdl end
                end
            end
        end
    end
    return best or (oldHitscan and oldHitscan(self))
end

Toggles.MegaHitboxEnabled:OnChanged(function(v)
    hitboxEnabled = v
    if v then
        if not oldHitscan and HitDetection then 
            oldHitscan = HitDetection.Hitscan 
            HitDetection.Hitscan = hookedHitscan 
        end
        Library:Notify('Ultra Hitbox â†’ ON', 4)
    else
        if oldHitscan and HitDetection then 
            HitDetection.Hitscan = oldHitscan 
            oldHitscan = nil 
        end
        Library:Notify('Ultra Hitbox â†’ OFF', 3)
    end
end)

if Options.HitboxScale then
    Options.HitboxScale:OnChanged(function() currentScale = Options.HitboxScale.Value or 1 end)
end

-- Ğ”Ğ¾Ğ±Ğ°Ğ²ÑŒ ÑÑ‚Ğ¾Ñ‚ Ğ±Ğ»Ğ¾Ğº ĞŸĞĞ¡Ğ›Ğ• MegaGroup Ğ² Combat tab (Ğ¿Ğ¾ÑĞ»Ğµ Toggles.MegaHitboxEnabled:OnChanged(...))

local SilentGroup = Tabs.Combat:AddLeftGroupbox('Silent Aim + FOV Circle')

SilentGroup:AddToggle('SilentAimEnabled', {
    Text = 'Enabled',
    Default = false,
    Tooltip = 'ĞĞ²Ñ‚Ğ¾-Ñ†ĞµĞ»Ğ¸Ñ‚ÑÑ Ğ² Ğ±Ğ»Ğ¸Ğ¶Ğ°Ğ¹ÑˆĞµĞ³Ğ¾ Ğ²Ñ€Ğ°Ğ³Ğ° Ğ² FOV â€¢ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ Ñ Ğ°Ğ±Ğ¸Ğ»ĞºĞ°Ğ¼Ğ¸ â€¢ Ğ¿Ñ€Ğ¸Ğ¾Ñ€Ğ¸Ñ‚ĞµÑ‚ Ğ½Ğ°Ğ´ Mega'
})

SilentGroup:AddSlider('SilentAimFOV', {
    Text = 'FOV Radius',
    Default = 150,
    Min = 50,
    Max = 500,
    Rounding = 0,
    Tooltip = 'Ğ Ğ°Ğ´Ğ¸ÑƒÑ ĞºÑ€ÑƒĞ³Ğ° (Ğ¿Ğ¸ĞºÑĞµĞ»Ğ¸) â€¢ Ñ‡ĞµĞ¼ Ğ¼ĞµĞ½ÑŒÑˆĞµ, Ñ‚ĞµĞ¼ Ñ‚Ğ¾Ñ‡Ğ½ĞµĞµ'
})

SilentGroup:AddToggle('SilentAimPredict', {
    Text = 'Prediction',
    Default = true,
    Tooltip = 'ĞšĞ¾Ğ¼Ğ¿ĞµĞ½ÑĞ°Ñ†Ğ¸Ñ ÑĞºĞ¾Ñ€Ğ¾ÑÑ‚Ğ¸ Ñ†ĞµĞ»Ğ¸ (Ğ¿Ñ€Ğ¾ÑÑ‚Ğ°Ñ Ğ¿Ñ€ĞµĞ´Ğ¸ĞºÑ‚)'
})

SilentGroup:AddLabel('FOV Color'):AddColorPicker('SilentAimFOVColor', {
    Default = Color3.fromRGB(255, 0, 100),
    Tooltip = 'Ğ¦Ğ²ĞµÑ‚ ĞºÑ€ÑƒĞ³Ğ° FOV'
})

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- Silent Aim Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ (Ğ´Ğ¾Ğ±Ğ°Ğ²ÑŒ Ğ¿Ğ¾ÑĞ»Ğµ bigGridOffsets Ğ¸ Ğ¿ĞµÑ€ĞµĞ´ hookedHitscan)
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local silentEnabled = false
local fovCircle = Drawing.new("Circle")
fovCircle.Thickness = 2
fovCircle.NumSides = 64
fovCircle.Filled = false
fovCircle.Transparency = 0.8
fovCircle.Radius = Options.SilentAimFOV.Value -- Ğ±ÑƒĞ´ĞµÑ‚ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ÑÑ‚ÑŒÑÑ
fovCircle.Visible = false

-- ĞŸÑ€ĞµĞ´Ğ¸ĞºÑ‚ ĞºĞ¾Ğ½ÑÑ‚Ğ°Ğ½Ñ‚Ñ‹ (Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ Ğ¿Ğ¾Ğ´ Ğ¸Ğ³Ñ€Ñƒ, 300-500 studs/s)
local PREDICT_SPEED = 350
local function getPredictedPos(root, head)
    if not Options.SilentAimPredict.Value then return head.Position end
    local vel = root.Velocity
    local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not myRoot then return head.Position end
    local dist3d = (head.Position - myRoot.Position).Magnitude
    local predictTime = dist3d / PREDICT_SPEED
    return head.Position + vel * predictTime
end

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- ĞĞĞ’Ğ«Ğ™ FOV Update (Ğ´Ğ¾Ğ±Ğ°Ğ²ÑŒ Ğ² RenderStepped ĞŸĞĞ¡Ğ›Ğ• UpdateNamesESP)
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local function UpdateFOVCircle()
    if not Toggles.SilentAimEnabled.Value then
        fovCircle.Visible = false
        return
    end
    fovCircle.Position = Vector2.new(mouse.X, mouse.Y)
    fovCircle.Radius = Options.SilentAimFOV.Value
    fovCircle.Color = Options.SilentAimFOVColor.Value
    fovCircle.Visible = true
end
RunService.RenderStepped:Connect(UpdateFovCircle)  -- Ğ´Ğ¾Ğ±Ğ°Ğ²ÑŒ ÑÑ‚Ñƒ ÑÑ‚Ñ€Ğ¾ĞºÑƒ Ğ² ĞºĞ¾Ğ½ĞµÑ† RenderStepped ÑĞµĞºÑ†Ğ¸Ğ¸

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- ĞĞ±Ğ½Ğ¾Ğ²Ğ»Ñ‘Ğ½Ğ½Ñ‹Ğ¹ hookedHitscan (Ğ—ĞĞœĞ•ĞĞ˜ ÑÑ‚Ğ°Ñ€Ñ‹Ğ¹ Ğ¿Ğ¾Ğ»Ğ½Ğ¾ÑÑ‚ÑŒÑ)
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local function hookedHitscan(self)
    -- ĞŸÑ€Ğ¸Ğ¾Ñ€Ğ¸Ñ‚ĞµÑ‚: Silent Aim > Mega Hitbox > Original
    if silentEnabled then
        -- ========== SILENT AIM LOGIC ==========
        local bestTarget, bestScreenDist = nil, math.huge
        local mousePos = Vector2.new(mouse.X, mouse.Y)
        local fovRadius = Options.SilentAimFOV.Value

        for _, plr in Players:GetPlayers() do
            if plr == LocalPlayer or not plr.Character then continue end

            local char = plr.Character
            local root = char:FindFirstChild("HumanoidRootPart")
            local head = char:FindFirstChild("Head")
            local hum = char:FindFirstChildOfClass("Humanoid")
            if not (root and head and hum and hum.Health > 0) then continue end

            local predictPos = getPredictedPos(root, head)
            local screenPos, onScreen = Camera:WorldToViewportPoint(predictPos)
            screenPos = Vector2.new(screenPos.X, screenPos.Y)

            if onScreen and (screenPos - mousePos).Magnitude <= fovRadius then
                local abilityName = self and self._name or "Unknown"
                if AbilityHandler and AbilityHandler.canBeAffected and AbilityHandler.canBeAffected(plr, abilityName) then
                    local screenDist = (screenPos - mousePos).Magnitude
                    if screenDist < bestScreenDist then
                        bestScreenDist = screenDist
                        bestTarget = char
                    endend
            end
        end
        if bestTarget then return bestTarget end
    elseif enabled then
        -- ========== MEGA HITBOX LOGIC (ÑÑ‚Ğ°Ñ€Ñ‹Ğ¹ ĞºĞ¾Ğ´) ==========
        -- ... (Ğ²ĞµÑÑŒ ÑÑ‚Ğ°Ñ€Ñ‹Ğ¹ grid ĞºĞ¾Ğ´ Ğ±ĞµĞ· Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸Ğ¹)
        local camera = Camera
        if not camera then return oldHitscan and oldHitscan(self) end
        local bestResult = nil
        local bestDist = math.huge
        for _, offset in bigGridOffsets do
            local probe = Vector2.new(mouse.X, mouse.Y) + offset + getJitter()
            local vx, vy = camera.ViewportSize.X, camera.ViewportSize.Y
            probe = Vector2.new(
                math.clamp(probe.X, -vx * 0.2, vx * 1.2),
                math.clamp(probe.Y, -vy * 0.2, vy * 1.2)
            )
            local ray = camera:ScreenPointToRay(probe.X, probe.Y)
            local direction = ray.Direction * SUPER_RANGE
            local params = RaycastParams.new()
            params.FilterDescendantsInstances = {LocalPlayer.Character or workspace}
            params.FilterType = Enum.RaycastFilterType.Exclude
            params.IgnoreWater = true
            local result = workspace:Raycast(ray.Origin, direction, params)
            if result and result.Instance then
                local model = result.Instance:FindFirstAncestorWhichIsA("Model")
                if model and model:FindFirstChildWhichIsA("Humanoid") then
                    local targetPlr = Players:GetPlayerFromCharacter(model)
                    if targetPlr and targetPlr ~= LocalPlayer then
                        local abilityName = self and self._name or "Unknown"
                        if AbilityHandler and AbilityHandler.canBeAffected and AbilityHandler.canBeAffected(targetPlr, abilityName) then
                            local dist = (result.Position - ray.Origin).Magnitude
                            if dist < bestDist then
                                bestDist = dist
                                bestResult = model
                            end
                            local effectiveOffset = offset + getJitter()
                            if effectiveOffset.Magnitude < centerThreshold then
                                return model
                            end
                        end
                    end
                end
            end
        end
        return bestResult or (oldHitscan and oldHitscan(self))
    end

    -- Original
    return oldHitscan and oldHitscan(self)
end

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- OnChanged Ğ´Ğ»Ñ Silent Aim (Ğ´Ğ¾Ğ±Ğ°Ğ²ÑŒ ĞŸĞĞ¡Ğ›Ğ• Mega OnChanged)
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Toggles.SilentAimEnabled:OnChanged(function()
    silentEnabled = Toggles.SilentAimEnabled.Value
    -- ĞĞ²Ñ‚Ğ¾-Ñ€Ğµ Ñ…ÑƒĞº (ĞµÑĞ»Ğ¸ Ğ½ÑƒĞ¶Ğ½Ğ¾)
    if HitDetection then
        if silentEnabled or enabled then
            if oldHitscan == nil then oldHitscan = HitDetection.Hitscan end
            HitDetection.Hitscan = hookedHitscan
        elseif not enabled then
            if oldHitscan then
                HitDetection.Hitscan = oldHitscan
                oldHitscan = nil
            end
        end
    end
end)

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- ĞĞ±Ğ½Ğ¾Ğ²Ğ¸ Options Ğ´Ğ»Ñ FOV (Ğ´Ğ¾Ğ±Ğ°Ğ²ÑŒ Ğ² RenderStepped Ğ¸Ğ»Ğ¸ Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ğ¾)
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Options.SilentAimFOV:OnChanged(function()
    fovCircle.Radius = Options.SilentAimFOV.Value
end)
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- Names + Distance ESP (Ñ Ñ„Ğ¸ĞºÑĞ¾Ğ¼ ĞºĞ¾Ğ¼ĞºĞ¾Ğ²Ğ°Ğ½Ğ¸Ñ)
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local ESPGroup = Tabs.Visuals:AddLeftGroupbox('Names + Distance ESP')
ESPGroup:AddToggle('NamesESPEnabled', {Text = 'Enabled', Default = false})
ESPGroup:AddLabel('Text Color'):AddColorPicker('NamesESPColor', {Default = Color3.fromRGB(255,255,255)})
ESPGroup:AddSlider('NamesESPDistance', {Text = 'Max Distance', Default = 800, Min = 200, Max = 1500, Rounding = 0})

local ESP_DATA = {}

local function WorldToScreen(pos)
    local vec, on = Camera:WorldToViewportPoint(pos)
    return Vector2.new(vec.X, vec.Y), on
end

local function Cleanup(plr)
    local d = ESP_DATA[plr] 
    if d then
        if d.nameTag then d.nameTag:Remove() end
        if d.userName then d.userName:Remove() end
        if d.dist then d.dist:Remove() end
        ESP_DATA[plr] = nil
    end
end

local function CreateESP(plr)
    if plr == LocalPlayer then return end
    Cleanup(plr)
    local d = {} ESP_DATA[plr] = d
    d.nameTag = Drawing.new("Text") 
    d.nameTag.Size=17 d.nameTag.Center=true d.nameTag.Outline=true 
    d.nameTag.OutlineColor=Color3.new(0,0,0) d.nameTag.Visible=false
    d.userName = Drawing.new("Text") 
    d.userName.Size=15 d.userName.Center=true d.userName.Outline=true 
    d.userName.OutlineColor=Color3.new(0,0,0) d.userName.Visible=false
    d.dist = Drawing.new("Text") 
    d.dist.Size=14 d.dist.Center=true d.dist.Outline=true 
    d.dist.OutlineColor=Color3.new(0,0,0) d.dist.Visible=false
end

local function UpdateNamesESP()
    if not Toggles.NamesESPEnabled or not Toggles.NamesESPEnabled.Value then 
        for _,d in pairs(ESP_DATA) do 
            if d.nameTag then d.nameTag.Visible=false end
            if d.userName then d.userName.Visible=false end
            if d.dist then d.dist.Visible=false end
        end 
        return 
    end
    local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") 
    if not root then return end
    local col = (Options.NamesESPColor and Options.NamesESPColor.Value) or Color3.fromRGB(255,255,255)
    local maxD = (Options.NamesESPDistance and Options.NamesESPDistance.Value) or 800
    local viewport = Camera.ViewportSize
    for plr,data in pairs(ESP_DATA) do
        local char = plr.Character 
        local r = char and char:FindFirstChild("HumanoidRootPart")
        local h = char and char:FindFirstChild("Head") 
        local hum = char and char:FindFirstChildOfClass("Humanoid")
        if not (r and h and hum and hum.Health > 0) then 
            if data.nameTag then data.nameTag.Visible=false end
            if data.userName then data.userName.Visible=false end
            if data.dist then data.dist.Visible=false end
            continue 
        end
        local dist = (r.Position - root.Position).Magnitude 
        if dist > maxD then 
            if data.nameTag then data.nameTag.Visible=false end
            if data.userName then data.userName.Visible=false end
            if data.dist then data.dist.Visible=false end
            continue 
        end
        local pos, onScr = WorldToScreen(h.Position + Vector3.new(0,0.5,0)) 
        if not onScr 
           or pos.X < -500 or pos.X > viewport.X + 500 
           or pos.Y < -500 or pos.Y > viewport.Y + 500 then
            if data.nameTag then data.nameTag.Visible=false end
            if data.userName then data.userName.Visible=false end
            if data.dist then data.dist.Visible=false end
            continue 
        end
        if data.nameTag then
            data.nameTag.Text = plr.DisplayName or plr.Name 
            data.nameTag.Position = pos - Vector2.new(0,22) 
            data.nameTag.Color = col 
            data.nameTag.Visible = true
        end
        if data.userName then
            data.userName.Text = "@"..plr.Name 
            data.userName.Position = pos + Vector2.new(0,2) 
            data.userName.Color = Color3.new(col.R*0.9,col.G*0.9,col.B*0.9) 
            data.userName.Visible = true
        end
        if data.dist then
            data.dist.Text = math.floor(dist).." studs" 
            data.dist.Position = pos + Vector2.new(0,20) 
            data.dist.Color = Color3.new(0.7,0.7,1) 
            data.dist.Visible = true
        end
    end
end

for _,p in Players:GetPlayers() do CreateESP(p) end
Players.PlayerAdded:Connect(function(p) 
    CreateESP(p) 
    p.CharacterAdded:Connect(function() task.wait(0.2) Cleanup(p) CreateESP(p) end) 
end)
Players.PlayerRemoving:Connect(Cleanup)
RunService.RenderStepped:Connect(UpdateNamesESP)

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- BYPASS AUTO DETECTION
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local BypassGroup = Tabs.Misc:AddRightGroupbox('Bypass Auto Detection')
local detectionBlocked = false

BypassGroup:AddToggle('BlockDetection', {
    Text = 'Block AutoclickerDetected Remote',
    Default = false,
    Callback = function(v)
        detectionBlocked = v
        Library:Notify(v and 'Autoclicker detection blocked' or 'Autoclicker detection unblocked', 4)
    end
})

pcall(function()
    local oldNamecall
    oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
        local method = getnamecallmethod()
        if detectionBlocked and self.Name == "AutoclickerDetected" and method == "FireServer" then
            return
        end
        return oldNamecall(self, ...)
    end))
end)

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- Rejoin + Instant Remote Reset (Ğ½Ğ¾Ñ€Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹, Ñ‡ĞµÑ€ĞµĞ· Remote)
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local ExtraMisc = Tabs.Misc:AddRightGroupbox('Extra')

local function doRejoin()
    Library:Notify('Rejoining current server...', 4)
    task.wait(0.4)
    TeleportService:Teleport(game.PlaceId, LocalPlayer)
end

ExtraMisc:AddButton({Text = 'Rejoin Server', Func = doRejoin})

local function resetCharacter()
    pcall(function()
        -- ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ Ñ€ĞµÑĞµÑ‚
        ReplicatedStorage.Remotes.GameServices.ToServer.PlayerReset:FireServer()
        
        -- Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ğµ limbo/ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ
        local args = {false}
        ReplicatedStorage.Remotes.GameServices.ToServer.LimboDecidedNew:InvokeServer(unpack(args))
    end)
    Library:Notify('Instant Remote Reset â†’ executed', 3)
end

ExtraMisc:AddButton({Text = 'Instant Remote Reset', Func = resetCharacter})

ExtraMisc:AddLabel('Reset Keybind'):AddKeyPicker('ResetKey', {
    Default = 'None',
    NoUI = true,
    Text = 'Reset Character',
    Mode = 'Toggle'
})

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- Status Indicator
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local StatusGroup = Tabs.Misc:AddLeftGroupbox('Status Indicator')

StatusGroup:AddToggle('ShowStatus', {
    Text = 'Show Status Overlay',
    Default = true,
    Callback = function(v)
        showStatusIndicator = v
        if not v and statusDrawing then
            statusDrawing:Remove()
            statusDrawing = nil
        end
    end
})

local function updateStatusIndicator()
    if not showStatusIndicator then return end

    if not statusDrawing then
        statusDrawing = Drawing.new("Text")
        statusDrawing.Size = 16
        statusDrawing.Center = false
        statusDrawing.Outline = true
        statusDrawing.OutlineColor = Color3.new(0,0,0)
        statusDrawing.Visible = true
    end

    local hitboxStatus = hitboxEnabled and "ON" or "OFF"

    statusDrawing.Text = string.format("Ultra Hitbox: %s", hitboxStatus)
    statusDrawing.Color = Color3.new(1,1,1)
    local viewport = Camera.ViewportSize
    statusDrawing.Position = Vector2.new(viewport.X - 220, 20)
end

RunService.RenderStepped:Connect(updateStatusIndicator)

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- ALL INPUT BINDINGS (SAFE)
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe then return end

    if input.KeyCode == Enum.KeyCode.N then
        resetCharacter()
    elseif Options.ResetKey and Options.ResetKey.Value and input.KeyCode == Options.ResetKey.Value then
        resetCharacter()
    end
end)

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- Anti-Shaders & Blind Screens (Sol, Ossox, fog, etc) â€” Ğ² Misc ÑĞ¿Ñ€Ğ°Ğ²Ğ°
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local AntiShaderGroup = Tabs.Misc:AddRightGroupbox('Anti-Shaders & Blind')

local FusionStates = nil
pcall(function()
    FusionStates = ReplicatedStorage:WaitForChild("Bindables"):WaitForChild("FusionStates", 8)
end)

local InstantTransition = nil
if FusionStates then
    pcall(function()
        InstantTransition = FusionStates:WaitForChild("InstantScreenTransition", 5)
    end)
end

local antiBlindEnabled = false
local oldNamecall = nil

-- ĞŸĞµÑ€ĞµÑ…Ğ²Ğ°Ñ‚ .Fire (ĞµÑĞ»Ğ¸ InstantTransition ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚)
if InstantTransition then
    pcall(function()
        oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
            local method = getnamecallmethod()
            local args = {...}
            
            if antiBlindEnabled 
               and self == InstantTransition 
               and method == "Fire" 
               and args[1] == true then
                return  -- Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµĞ¼ Ğ²ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ ÑĞ»ĞµĞ¿Ğ¾Ñ‚Ñ‹
            end
            
            return oldNamecall(self, ...)
        end))
    end)
end

local autoClearThread = nil

local function enableAntiBlind()
    antiBlindEnabled = true
    
    -- ĞĞ²Ñ‚Ğ¾-Ğ¾Ñ‡Ğ¸ÑÑ‚ĞºĞ° ĞºĞ°Ğ¶Ğ´Ñ‹Ğµ 0.3 ÑĞµĞº
    autoClearThread = task.spawn(function()
        while antiBlindEnabled do
            if InstantTransition then
                pcall(function()
                    InstantTransition:Fire(false)
                end)
            end
            task.wait(0.3)
        end
    end)
    
    -- Fullbright + Ğ¾Ñ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ ÑÑ„Ñ„ĞµĞºÑ‚Ğ¾Ğ²
    pcall(function()
        game.Lighting.Brightness = 3
        game.Lighting.GlobalShadows = false
        game.Lighting.Ambient = Color3.fromRGB(180, 180, 180)
    end)
    
    pcall(function()
        for _, obj in game.Lighting:GetDescendants() do
            if obj:IsA("PostEffect") then obj.Enabled = false end
            if obj:IsA("Atmosphere") then obj.Density = 0 end
        end
    end)
    
    Library:Notify("Anti-Shaders & Blind â†’ ON", 4)
end

local function disableAntiBlind()
    antiBlindEnabled = false
    
    if autoClearThread then
        task.cancel(autoClearThread)
        autoClearThread = nil
    end
    
    pcall(function()
        game.Lighting.Brightness = 1
        game.Lighting.GlobalShadows = true
        game.Lighting.Ambient = Color3.fromRGB(0,0,0)
    end)
    
    Library:Notify("Anti-Shaders & Blind â†’ OFF", 4)
end

AntiShaderGroup:AddToggle('AntiBlindToggle', {
    Text = 'Anti Blind / Shaders / Fog',
    Default = false,
    Callback = function(value)
        if value then
            enableAntiBlind()
        else
            disableAntiBlind()
        end
    end
})

AntiShaderGroup:AddButton({
    Text = 'Force Clear Screen',
    Func = function()
        if InstantTransition then
            pcall(function()
                InstantTransition:Fire(false)
            end)
            Library:Notify("Force clear sent", 2)
        else
            Library:Notify("No InstantScreenTransition found", 4)
        end
    end
})
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- Auto Shop Buyer
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local ShopGroup = Tabs.Misc:AddLeftGroupbox('Auto Buy Items')

local selectedItem = "HealingHerb"
local amount = 1
local buying = false

ShopGroup:AddDropdown('ItemToBuy', {
    Text = 'Item',
    Default = 'HealingHerb',
    Values = {
        "HealingHerb", "Bouquet", "Candle", "Flashlight",
        "WoodenStake", "VervainGrenade", "WolfsbaneGrenade",
        "WhiteOakStake", "GoldenArrow", "RedOakStake",
        "IncendiaryArrow", "ExplosiveArrow", "MagicShackles"
    },
    Callback = function(v)
        selectedItem = v
    end
})

ShopGroup:AddSlider('BuyAmount', {
    Text = 'Amount (per click)',
    Default = 1,
    Min = 1,
    Max = 50,
    Rounding = 0,
    Callback = function(v)
        amount = v
    end
})

ShopGroup:AddButton({
    Text = 'Buy Once',
    Func = function()
        local remote = game.ReplicatedStorage.Remotes.GameServices.ToServer.ItemPurchaseRequested_
        for i = 1, amount do
            remote:FireServer("PurchaseTool", selectedItem)
            task.wait(0.06)   -- tiny delay â€“ helps avoid kick / rate-limit
        end
        Library:Notify("Sent Ã—" .. amount .. " â†’ " .. selectedItem, 2.5)
    end
})

ShopGroup:AddToggle('AutoBuyToggle', {
    Text = 'Auto Buy (hold)',
    Default = false,
    Callback = function(v)
        buying = v
        if v then
            Library:Notify("Auto-buy started â†’ " .. selectedItem, 4)
            task.spawn(function()
                while buying do
                    local remote = game.ReplicatedStorage.Remotes.GameServices.ToServer.ItemPurchaseRequested_
                    remote:FireServer("PurchaseTool", selectedItem)
                    task.wait(0.12) -- adjust if getting kicked / flagged
                end
            end)
        else
            Library:Notify("Auto-buy stopped", 3)
        end
    end
})

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- AUTO SOUL COIN FARM + TELEPORT (v3 - TP to Coins)
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local SoulCoinGroup = Tabs.Misc:AddRightGroupbox('Auto Soul Coin Farm + TP')

local autoTPPickup = false
local tpSpeed = 0.3  -- delay between TPs
local pickupRemote = ReplicatedStorage.Remotes.QuestService.ToServer.PickupQuestItem_

local function getAllCoinObjects()
    local coins = {}
    for _, obj in workspace:GetDescendants() do
        if (obj.Name:lower():find("soulcoin") or obj:FindFirstChild("SoulCoin")) and obj:IsA("BasePart") then
            table.insert(coins, obj)
        end
    end
    -- Also check quest item parents (from decomp: objectRef)
    for _, obj in workspace:GetDescendants() do
        if obj.Name:match("[A-Za-z]+") and obj:FindFirstChildWhichIsA("BasePart") then  -- potential spawns
            local coinChild = obj:FindFirstChild("SoulCoin")
            if coinChild then
                table.insert(coins, coinChild)
            end
        end
    end
    return coins
end

local function tpToCoin(coin)
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
    local hrp = LocalPlayer.Character.HumanoidRootPart
    local targetCFrame = coin.CFrame + Vector3.new(0, 3, 0) + Vector3.new(math.random(-2,2), 0, math.random(-2,2))  -- jitter anti-detect
    hrp.CFrame = targetCFrame
end

SoulCoinGroup:AddToggle('AutoTPPickup', {
    Text = 'Auto TP + Pickup Coins',
    Default = false,
    Callback = function(v)
        autoTPPickup = v
        if v then
            Library:Notify('Auto TP Coins â†’ ON | Will teleport & collect all!', 4)
            task.spawn(function()
                while autoTPPickup do
                    local coins = getAllCoinObjects()
                    if #coins > 0 then
                        Library:Notify(#coins .. ' coins found â†’ TPing...', 2)
                        for _, coin in ipairs(coins) do
                            if coin and coin.Parent then
                                tpToCoin(coin)
                                task.wait(0.1)  -- micro delay after TP
                                pcall(function()
                                    pickupRemote:InvokeServer("Ferryman", coin.Name or coin.Parent.Name)
                                end)
                                task.wait(tpSpeed)
                            end
                        end
                    else
                        Library:Notify('No coins found â†’ walk around map', 3)
                    end
                    task.wait(1)  -- respawn check delay
                end
            end)
        else
            Library:Notify('Auto TP Coins â†’ OFF', 3)
        end
    end
})

SoulCoinGroup:AddSlider('TPSpeed', {
    Text = 'TP Delay',
    Default = 0.3,
    Min = 0.1,
    Max = 2,
    Rounding = 2,
    Callback = function(value)
        tpSpeed = value
    end
})

SoulCoinGroup:AddButton({
    Text = 'TP to Nearest Coin (Single)',
    Func = function()
        local coins = getAllCoinObjects()
        if #coins > 0 then
            local nearest = coins[1]  -- or sort by distance
            for _, coin in ipairs(coins) do
                local dist = (LocalPlayer.Character.HumanoidRootPart.Position - coin.Position).Magnitude
                if dist < (LocalPlayer.Character.HumanoidRootPart.Position - nearest.Position).Magnitude then
                    nearest = coin
                end
            end
            tpToCoin(nearest)
            pcall(function()
                pickupRemote:InvokeServer("Ferryman", nearest.Name or nearest.Parent.Name)
            end)
            Library:Notify('TPed to nearest coin & collected!', 3)
        else
            Library:Notify('No coins nearby!', 4)
        end
    end
})

SoulCoinGroup:AddButton({
    Text = 'TP + Pickup ALL Coins Now',
    Func = function()
        local coins = getAllCoinObjects()
        Library:Notify('TPing to ' .. #coins .. ' coins...', 3)
        for _, coin in ipairs(coins) do
            if coin and coin.Parent then
                tpToCoin(coin)
                task.wait(0.15)
                pcall(function()
                    pickupRemote:InvokeServer("Ferryman", coin.Name or coin.Parent.Name)
                end)
                task.wait(0.2)
            end
        end
        Library:Notify('All coins collected! Check backpack.', 4)
    end
})

SoulCoinGroup:AddLabel('â€¢ MF: Waterfall, Mill, Greenhouse, Parkour')


-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- LOW PING HOP: Vampire Legends 2 - Mystic Falls (10561483644)
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- âœ… PUBLIC & ACTIVE (561 players, no restrictions) - Fixes Error 773!
-- Updated Jan 19, 2026 | Server size 30 | Ferryman farms confirmed

local MysticFallsHop = Tabs.Misc:AddLeftGroupbox('Vampire Legends 2 - Mystic Falls Hop')

local maxPingMF = 120  -- UK optimized (40-120ms EU servers)
local placeIdMF = 10561483644  -- Confirmed public PlaceId

local function lowPingHopMF()
    local HttpService = game:GetService("HttpService")
    local TeleportService = game:GetService("TeleportService")
    local currentJobId = game.JobId
    
    Library:Notify('ğŸ” Scanning Mystic Falls servers (low ping <' .. maxPingMF .. 'ms)...', 4)
    
    local servers = {}
    local cursor = nil
    local pages = 0
    
    repeat
        local success, result = pcall(function()
            local url = "https://games.roblox.com/v1/games/" .. placeIdMF .. "/servers/Public?sortOrder=Asc&limit=50"
            if cursor then url = url .. "&cursor=" .. cursor end
            return HttpService:JSONDecode(game:HttpGet(url))
        end)
        
        if success and result and result.data then
            for _, server in result.data do
                local ping = server.ping or 999
                local fill = (server.playing / server.maxPlayers) * 100
                if ping <= maxPingMF and fill <= 85 and server.id ~= currentJobId then  -- <85% full
                    table.insert(servers, {
                        id = server.id,
                        ping = ping,
                        pop = server.playing .. "/" .. server.maxPlayers
                    })
                end
            end
            cursor = result.nextPageCursor
            pages = pages + 1
        end
        task.wait(0.15)
    until not cursor or pages >= 6
    
    if #servers == 0 then
        Library:Notify('No low-ping servers? Rejoining public...', 4)
        TeleportService:Teleport(placeIdMF)
        return
    end
    
    -- Sort: Lowest ping â†’ lowest pop
    table.sort(servers, function(a, b)
        if a.ping ~= b.ping then return a.ping < b.ping end
        return a.pop < b.pop
    end)
    
    local best = servers[1]
    Library:Notify('ğŸ¯ Hopping: ' .. best.ping .. 'ms | ' .. best.pop .. ' players', 3)
    
    pcall(TeleportService.TeleportToPlaceInstance, TeleportService, placeIdMF, best.id, LocalPlayer)
end

MysticFallsHop:AddButton({
    Text = 'ğŸš€ Hop Lowest Ping Mystic Falls',
    Func = lowPingHopMF
})

MysticFallsHop:AddSlider('MaxPingMF', {
    Text = 'Max Ping (ms)',
    Default = 120,
    Min = 40,
    Max = 250,
    Rounding = 0,
    Callback = function(v) maxPingMF = v end
})

MysticFallsHop:AddButton({
    Text = 'Quick Rejoin Mystic Falls',
    Func = function()
        game:GetService("TeleportService"):Teleport(placeIdMF)
    end
})


MysticFallsHop:AddLabel('â€¢ Public game (561 active, 35K favs, updated 1/12/26)<grok-card data-id="470227" data-type="citation_card" ></grok-card>')
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- SINGLE ESCAPE FROM CARRY BY KEY O
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

local CarryRemote = game:GetService("ReplicatedStorage")
    :WaitForChild("Remotes")
    :WaitForChild("CarryService")
    :WaitForChild("EscapedCarry")

-- Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ¾ÑĞ²Ğ¾Ğ±Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¸Ñ ÑĞµĞ±Ñ
local function escapeCarrySelf()
    pcall(function()
        CarryRemote:FireServer()  -- Ğ±ĞµĞ· Ğ°Ñ€Ğ³ÑƒĞ¼ĞµĞ½Ñ‚Ğ¾Ğ² â€” Ğ´Ğ»Ñ ÑĞµĞ±Ñ
        -- Ğ•ÑĞ»Ğ¸ Ğ¸Ğ³Ñ€Ğ° Ñ‚Ñ€ĞµĞ±ÑƒĞµÑ‚ Ğ¿ĞµÑ€ĞµĞ´Ğ°Ñ‚ÑŒ ÑĞµĞ±Ñ ĞºĞ°Ğº Ğ°Ñ€Ğ³ÑƒĞ¼ĞµĞ½Ñ‚, Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ñ‚Ğ°Ğº:
        -- CarryRemote:FireServer(LocalPlayer)
    end)
end

-- ĞŸĞµÑ€ĞµÑ…Ğ²Ğ°Ñ‚ Ğ½Ğ°Ğ¶Ğ°Ñ‚Ğ¸Ñ ĞºĞ»Ğ°Ğ²Ğ¸ÑˆĞ¸ O
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end  -- Ğ½Ğµ Ñ€ĞµĞ°Ğ³Ğ¸Ñ€ÑƒĞµĞ¼ Ğ½Ğ° Ñ‡Ğ°Ñ‚/Ğ¸Ğ½Ğ²ĞµĞ½Ñ‚Ğ°Ñ€ÑŒ Ğ¸ Ñ‚.Ğ´.
    
    if input.KeyCode == Enum.KeyCode.O then
        escapeCarrySelf()
        Library:Notify('O â†’ Escaped from carry!', 2)
    end
end)

-- Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞµĞ¼ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ Ğ² Ğ¸Ğ½Ñ‚ĞµÑ€Ñ„ĞµĞ¹Ñ (Ğ´Ğ»Ñ ÑƒĞ´Ğ¾Ğ±ÑÑ‚Ğ²Ğ°)
local AntiCarryGroup = Tabs.Misc:AddLeftGroupbox('ğŸ†“ Anti-Carry (Key O)')

AntiCarryGroup:AddLabel('ĞĞ°Ğ¶Ğ¼Ğ¸ O â†’ Ğ¼Ğ¾Ğ¼ĞµĞ½Ñ‚Ğ°Ğ»ÑŒĞ½Ğ¾ Ğ²Ñ‹Ñ€Ğ²Ğ°Ñ‚ÑŒÑÑ Ğ¸Ğ· carry')
AntiCarryGroup:AddLabel('Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ĞºĞ¾Ğ³Ğ´Ğ° Ñ‚ĞµĞ±Ñ Ğ½ĞµÑÑƒÑ‚')
AntiCarryGroup:AddLabel('Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾: Ğ¾Ğ´Ğ¸Ğ½Ğ¾Ñ‡Ğ½Ñ‹Ğ¹ Ğ²Ñ‹Ğ·Ğ¾Ğ² remote')

-- ĞĞ¿Ñ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾: Ğ¸Ğ½Ğ´Ğ¸ĞºĞ°Ñ‚Ğ¾Ñ€ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ° (ĞµÑĞ»Ğ¸ Ñ…Ğ¾Ñ‡ĞµÑˆÑŒ Ğ²Ğ¸Ğ´ĞµÑ‚ÑŒ, ĞºĞ¾Ğ³Ğ´Ğ° Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ½Ğ°Ğ¶Ğ°Ñ‚ÑŒ)
AntiCarryGroup:AddToggle('ShowCarryStatus', {
    Text = 'ĞŸĞ¾ĞºĞ°Ğ·Ñ‹Ğ²Ğ°Ñ‚ÑŒ ÑÑ‚Ğ°Ñ‚ÑƒÑ carry (ĞµÑĞ»Ğ¸ ĞµÑÑ‚ÑŒ)',
    Default = false,
    Callback = function(v)
        -- ĞœĞ¾Ğ¶Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¸Ğ½Ğ´Ğ¸ĞºĞ°Ñ‚Ğ¾Ñ€, ĞµÑĞ»Ğ¸ Ğ½Ğ°Ğ¹Ğ´ĞµÑˆÑŒ Ğ°Ñ‚Ñ€Ğ¸Ğ±ÑƒÑ‚ "IsCarried" Ğ¸Ğ»Ğ¸ Ğ¿Ğ¾Ğ´Ğ¾Ğ±Ğ½Ğ¾Ğµ
        -- ĞŸĞ¾ĞºĞ° Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ Ğ·Ğ°Ğ³Ğ»ÑƒÑˆĞºĞ°
    end
})

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- UI Settings
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')
MenuGroup:AddButton('Unload', function() Library:Unload() end)
MenuGroup:AddLabel('Menu Bind'):AddKeyPicker('MenuKeybind', {Default = 'End', NoUI = true})

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({'MenuKeybind'})

ThemeManager:SetFolder('KatyVampHub')
SaveManager:SetFolder('KatyVampHub')
SaveManager:BuildConfigSection(Tabs['UI Settings'])
ThemeManager:ApplyToTab(Tabs['UI Settings'])
SaveManager:LoadAutoloadConfig()

Library:Notify('Hub loaded â€¢ Instant Remote Reset â€¢ Anti-Shaders & Blind â€¢ Safe', 6)
print("Katy Vampire Legends 2 Hub â€¢ FULLY SAFE VERSION LOADED")
