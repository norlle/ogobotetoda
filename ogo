-- Katy's Vampire Legends 2 Hub (LinoriaLib - Minimal & Safe)
-- violin-suzutsuki mirror | FULLY SAFE VERSION

local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

local Window = Library:CreateWindow({
    Title = 'Norlape\'s Hub ğŸ§›â€â™€ï¸',
    Center = true,
    AutoShow = true,
})

local Tabs = {
    Combat = Window:AddTab('Combat'),
    Visuals = Window:AddTab('Visuals'),
    Misc = Window:AddTab('Misc'),
    ['UI Settings'] = Window:AddTab('UI Settings'),
}

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TeleportService = game:GetService("TeleportService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local mouse = LocalPlayer:GetMouse()
mouse.Icon = "rbxasset://textures\\GunCursor.png"

-- Global variables
local hitboxEnabled = false
local showStatusIndicator = true
local statusDrawing = nil

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- ULTRA WIDE HITBOX (SAFE)
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local MegaGroup = Tabs.Combat:AddLeftGroupbox('ULTRA WIDE HITBOX')
MegaGroup:AddToggle('MegaHitboxEnabled', {Text = 'Enabled', Default = false})
MegaGroup:AddSlider('HitboxScale', {Text = 'Grid Scale', Default = 1.0, Min = 0.4, Max = 2.5, Rounding = 2, Suffix = 'Ã—'})

local baseGridOffsets = {}
local function addRingPoints(radius, count)
    if radius == 0 then table.insert(baseGridOffsets, Vector2.new(0,0)) return end
    for i = 0, count - 1 do
        local angle = (i / count) * math.pi * 2 + math.rad(22.5)
        table.insert(baseGridOffsets, Vector2.new(math.cos(angle)*radius, math.sin(angle)*radius))
    end
end

addRingPoints(0,1) addRingPoints(45,8) addRingPoints(100,12) addRingPoints(180,16) addRingPoints(260,8)
local extras = {Vector2.new(320,320),Vector2.new(-320,-320),Vector2.new(320,-320),Vector2.new(-320,320),Vector2.new(0,380),Vector2.new(0,-380),Vector2.new(380,0),Vector2.new(-380,0)}
for _,v in extras do table.insert(baseGridOffsets,v) end

local SUPER_RANGE = 4800
local function getJitter() return Vector2.new(math.random(-15,15), math.random(-15,15)) end

local HitDetection, AbilityHandler
pcall(function()
    HitDetection = require(ReplicatedStorage.ModuleScripts.TargetSystem.HitDetection)
    AbilityHandler = require(LocalPlayer.PlayerScripts.ModuleScripts.AbilityHandler)
end)

local oldHitscan = nil
local currentScale = 1.0

local function getScaledOffsets()
    local s = (Options.HitboxScale and Options.HitboxScale.Value) or 1
    local t = {}
    for _,o in baseGridOffsets do table.insert(t, o * s) end
    return t
end

local function hookedHitscan(self)
    if not hitboxEnabled or not HitDetection or not AbilityHandler then 
        return oldHitscan and oldHitscan(self) 
    end
    local cam = workspace.CurrentCamera 
    if not cam then return oldHitscan and oldHitscan(self) end
    local best, bestD = nil, math.huge
    local centerTh = 70 * currentScale
    local offs = getScaledOffsets()
    for _, offset in offs do
        local probe = Vector2.new(mouse.X, mouse.Y) + offset + getJitter()
        local vx,vy = cam.ViewportSize.X, cam.ViewportSize.Y
        probe = Vector2.new(math.clamp(probe.X, -vx*0.2, vx*1.2), math.clamp(probe.Y, -vy*0.2, vy*1.2))
        local ray = cam:ScreenPointToRay(probe.X, probe.Y)
        local dir = ray.Direction * SUPER_RANGE
        local p = RaycastParams.new()
        p.FilterDescendantsInstances = {LocalPlayer.Character or workspace}
        p.FilterType = Enum.RaycastFilterType.Exclude
        p.IgnoreWater = true
        local res = workspace:Raycast(ray.Origin, dir, p)
        if res then
            local mdl = res.Instance:FindFirstAncestorWhichIsA("Model")
            if mdl and mdl:FindFirstChildWhichIsA("Humanoid") then
                local tp = Players:GetPlayerFromCharacter(mdl)
                if tp and tp ~= LocalPlayer and AbilityHandler.canBeAffected(tp, self._name) then
                    local d = (res.Position - ray.Origin).Magnitude
                    if d < bestD then bestD = d best = mdl end
                    if (offset + getJitter()).Magnitude < centerTh then return mdl end
                end
            end
        end
    end
    return best or (oldHitscan and oldHitscan(self))
end

Toggles.MegaHitboxEnabled:OnChanged(function(v)
    hitboxEnabled = v
    if v then
        if not oldHitscan and HitDetection then 
            oldHitscan = HitDetection.Hitscan 
            HitDetection.Hitscan = hookedHitscan 
        end
        Library:Notify('Ultra Hitbox â†’ ON', 4)
    else
        if oldHitscan and HitDetection then 
            HitDetection.Hitscan = oldHitscan 
            oldHitscan = nil 
        end
        Library:Notify('Ultra Hitbox â†’ OFF', 3)
    end
end)

if Options.HitboxScale then
    Options.HitboxScale:OnChanged(function() currentScale = Options.HitboxScale.Value or 1 end)
end

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- TRUE GOD MODE (Add to Combat Tab - Right Groupbox)
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local TrueGodGroup = Tabs.Combat:AddRightGroupbox('ğŸ›¡ï¸ True God Mode')

local trueGodEnabled = false
local oldCanBeAffected = nil
local healthLoop = nil

local function toggleTrueGod(v)
    if v then
        Library:Notify('ğŸ›¡ï¸ True God â†’ ON | Immune to ALL attacks!', 5)
        
        -- Immunity: Hook AbilityHandler.canBeAffected
        if AbilityHandler and not oldCanBeAffected then
            oldCanBeAffected = AbilityHandler.canBeAffected
            AbilityHandler.canBeAffected = function(tp, abilityName)
                if tp == LocalPlayer then return false end  -- YOU IMMUNE
                return oldCanBeAffected(tp, abilityName)
            end
        end
        
        -- Infinite Health Loop
        healthLoop = task.spawn(function()
            while trueGodEnabled do
                if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                    LocalPlayer.Character.Humanoid.Health = LocalPlayer.Character.Humanoid.MaxHealth
                end
                task.wait(0.1)
            end
        end)
        
    else
        Library:Notify('ğŸ›¡ï¸ True God â†’ OFF', 3)
        
        -- Restore
        if AbilityHandler and oldCanBeAffected then
            AbilityHandler.canBeAffected = oldCanBeAffected
            oldCanBeAffected = nil
        end
        
        if healthLoop then task.cancel(healthLoop) healthLoop = nil end
    end
end

TrueGodGroup:AddToggle('TrueGodToggle', {
    Text = 'True God (Immune to Abilities)',
    Default = false,
    Callback = toggleTrueGod
})

TrueGodGroup:AddLabel('Blocks: Bites, Claws, Spells, Arrows')
TrueGodGroup:AddLabel('+ Infinite HP | Toggle OFF to restore')

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- Names + Distance ESP (Ñ Ñ„Ğ¸ĞºÑĞ¾Ğ¼ ĞºĞ¾Ğ¼ĞºĞ¾Ğ²Ğ°Ğ½Ğ¸Ñ)
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local ESPGroup = Tabs.Visuals:AddLeftGroupbox('Names + Distance ESP')
ESPGroup:AddToggle('NamesESPEnabled', {Text = 'Enabled', Default = false})
ESPGroup:AddLabel('Text Color'):AddColorPicker('NamesESPColor', {Default = Color3.fromRGB(255,255,255)})
ESPGroup:AddSlider('NamesESPDistance', {Text = 'Max Distance', Default = 800, Min = 200, Max = 1500, Rounding = 0})

local ESP_DATA = {}

local function WorldToScreen(pos)
    local vec, on = Camera:WorldToViewportPoint(pos)
    return Vector2.new(vec.X, vec.Y), on
end

local function Cleanup(plr)
    local d = ESP_DATA[plr] 
    if d then
        if d.nameTag then d.nameTag:Remove() end
        if d.userName then d.userName:Remove() end
        if d.dist then d.dist:Remove() end
        ESP_DATA[plr] = nil
    end
end

local function CreateESP(plr)
    if plr == LocalPlayer then return end
    Cleanup(plr)
    local d = {} ESP_DATA[plr] = d
    d.nameTag = Drawing.new("Text") 
    d.nameTag.Size=17 d.nameTag.Center=true d.nameTag.Outline=true 
    d.nameTag.OutlineColor=Color3.new(0,0,0) d.nameTag.Visible=false
    d.userName = Drawing.new("Text") 
    d.userName.Size=15 d.userName.Center=true d.userName.Outline=true 
    d.userName.OutlineColor=Color3.new(0,0,0) d.userName.Visible=false
    d.dist = Drawing.new("Text") 
    d.dist.Size=14 d.dist.Center=true d.dist.Outline=true 
    d.dist.OutlineColor=Color3.new(0,0,0) d.dist.Visible=false
end

local function UpdateNamesESP()
    if not Toggles.NamesESPEnabled or not Toggles.NamesESPEnabled.Value then 
        for _,d in pairs(ESP_DATA) do 
            if d.nameTag then d.nameTag.Visible=false end
            if d.userName then d.userName.Visible=false end
            if d.dist then d.dist.Visible=false end
        end 
        return 
    end
    local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") 
    if not root then return end
    local col = (Options.NamesESPColor and Options.NamesESPColor.Value) or Color3.fromRGB(255,255,255)
    local maxD = (Options.NamesESPDistance and Options.NamesESPDistance.Value) or 800
    local viewport = Camera.ViewportSize
    for plr,data in pairs(ESP_DATA) do
        local char = plr.Character 
        local r = char and char:FindFirstChild("HumanoidRootPart")
        local h = char and char:FindFirstChild("Head") 
        local hum = char and char:FindFirstChildOfClass("Humanoid")
        if not (r and h and hum and hum.Health > 0) then 
            if data.nameTag then data.nameTag.Visible=false end
            if data.userName then data.userName.Visible=false end
            if data.dist then data.dist.Visible=false end
            continue 
        end
        local dist = (r.Position - root.Position).Magnitude 
        if dist > maxD then 
            if data.nameTag then data.nameTag.Visible=false end
            if data.userName then data.userName.Visible=false end
            if data.dist then data.dist.Visible=false end
            continue 
        end
        local pos, onScr = WorldToScreen(h.Position + Vector3.new(0,0.5,0)) 
        if not onScr 
           or pos.X < -500 or pos.X > viewport.X + 500 
           or pos.Y < -500 or pos.Y > viewport.Y + 500 then
            if data.nameTag then data.nameTag.Visible=false end
            if data.userName then data.userName.Visible=false end
            if data.dist then data.dist.Visible=false end
            continue 
        end
        if data.nameTag then
            data.nameTag.Text = plr.DisplayName or plr.Name 
            data.nameTag.Position = pos - Vector2.new(0,22) 
            data.nameTag.Color = col 
            data.nameTag.Visible = true
        end
        if data.userName then
            data.userName.Text = "@"..plr.Name 
            data.userName.Position = pos + Vector2.new(0,2) 
            data.userName.Color = Color3.new(col.R*0.9,col.G*0.9,col.B*0.9) 
            data.userName.Visible = true
        end
        if data.dist then
            data.dist.Text = math.floor(dist).." studs" 
            data.dist.Position = pos + Vector2.new(0,20) 
            data.dist.Color = Color3.new(0.7,0.7,1) 
            data.dist.Visible = true
        end
    end
end

for _,p in Players:GetPlayers() do CreateESP(p) end
Players.PlayerAdded:Connect(function(p) 
    CreateESP(p) 
    p.CharacterAdded:Connect(function() task.wait(0.2) Cleanup(p) CreateESP(p) end) 
end)
Players.PlayerRemoving:Connect(Cleanup)
RunService.RenderStepped:Connect(UpdateNamesESP)

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- BYPASS AUTO DETECTION
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local BypassGroup = Tabs.Misc:AddRightGroupbox('Bypass Auto Detection')
local detectionBlocked = false

BypassGroup:AddToggle('BlockDetection', {
    Text = 'Block AutoclickerDetected Remote',
    Default = false,
    Callback = function(v)
        detectionBlocked = v
        Library:Notify(v and 'Autoclicker detection blocked' or 'Autoclicker detection unblocked', 4)
    end
})

pcall(function()
    local oldNamecall
    oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
        local method = getnamecallmethod()
        if detectionBlocked and self.Name == "AutoclickerDetected" and method == "FireServer" then
            return
        end
        return oldNamecall(self, ...)
    end))
end)

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- Rejoin + Instant Remote Reset (Ğ½Ğ¾Ñ€Ğ¼Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹, Ñ‡ĞµÑ€ĞµĞ· Remote)
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local ExtraMisc = Tabs.Misc:AddRightGroupbox('Extra')

local function doRejoin()
    Library:Notify('Rejoining current server...', 4)
    task.wait(0.4)
    TeleportService:Teleport(game.PlaceId, LocalPlayer)
end

ExtraMisc:AddButton({Text = 'Rejoin Server', Func = doRejoin})

local function resetCharacter()
    pcall(function()
        -- ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ¹ Ñ€ĞµÑĞµÑ‚
        ReplicatedStorage.Remotes.GameServices.ToServer.PlayerReset:FireServer()
        
        -- Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ğµ limbo/ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ñ
        local args = {false}
        ReplicatedStorage.Remotes.GameServices.ToServer.LimboDecidedNew:InvokeServer(unpack(args))
    end)
    Library:Notify('Instant Remote Reset â†’ executed', 3)
end

ExtraMisc:AddButton({Text = 'Instant Remote Reset', Func = resetCharacter})

ExtraMisc:AddLabel('Reset Keybind'):AddKeyPicker('ResetKey', {
    Default = 'None',
    NoUI = true,
    Text = 'Reset Character',
    Mode = 'Toggle'
})

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- Status Indicator
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local StatusGroup = Tabs.Misc:AddLeftGroupbox('Status Indicator')

StatusGroup:AddToggle('ShowStatus', {
    Text = 'Show Status Overlay',
    Default = true,
    Callback = function(v)
        showStatusIndicator = v
        if not v and statusDrawing then
            statusDrawing:Remove()
            statusDrawing = nil
        end
    end
})

local function updateStatusIndicator()
    if not showStatusIndicator then return end

    if not statusDrawing then
        statusDrawing = Drawing.new("Text")
        statusDrawing.Size = 16
        statusDrawing.Center = false
        statusDrawing.Outline = true
        statusDrawing.OutlineColor = Color3.new(0,0,0)
        statusDrawing.Visible = true
    end

    local hitboxStatus = hitboxEnabled and "ON" or "OFF"

    statusDrawing.Text = string.format("Ultra Hitbox: %s", hitboxStatus)
    statusDrawing.Color = Color3.new(1,1,1)
    local viewport = Camera.ViewportSize
    statusDrawing.Position = Vector2.new(viewport.X - 220, 20)
end

RunService.RenderStepped:Connect(updateStatusIndicator)

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- ALL INPUT BINDINGS (SAFE)
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe then return end

    if input.KeyCode == Enum.KeyCode.N then
        resetCharacter()
    elseif Options.ResetKey and Options.ResetKey.Value and input.KeyCode == Options.ResetKey.Value then
        resetCharacter()
    end
end)

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- Anti-Shaders & Blind Screens (Sol, Ossox, fog, etc) â€” Ğ² Misc ÑĞ¿Ñ€Ğ°Ğ²Ğ°
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local AntiShaderGroup = Tabs.Misc:AddRightGroupbox('Anti-Shaders & Blind')

local FusionStates = nil
pcall(function()
    FusionStates = ReplicatedStorage:WaitForChild("Bindables"):WaitForChild("FusionStates", 8)
end)

local InstantTransition = nil
if FusionStates then
    pcall(function()
        InstantTransition = FusionStates:WaitForChild("InstantScreenTransition", 5)
    end)
end

local antiBlindEnabled = false
local oldNamecall = nil

-- ĞŸĞµÑ€ĞµÑ…Ğ²Ğ°Ñ‚ .Fire (ĞµÑĞ»Ğ¸ InstantTransition ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚)
if InstantTransition then
    pcall(function()
        oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
            local method = getnamecallmethod()
            local args = {...}
            
            if antiBlindEnabled 
               and self == InstantTransition 
               and method == "Fire" 
               and args[1] == true then
                return  -- Ğ±Ğ»Ğ¾ĞºĞ¸Ñ€ÑƒĞµĞ¼ Ğ²ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ ÑĞ»ĞµĞ¿Ğ¾Ñ‚Ñ‹
            end
            
            return oldNamecall(self, ...)
        end))
    end)
end

local autoClearThread = nil

local function enableAntiBlind()
    antiBlindEnabled = true
    
    -- ĞĞ²Ñ‚Ğ¾-Ğ¾Ñ‡Ğ¸ÑÑ‚ĞºĞ° ĞºĞ°Ğ¶Ğ´Ñ‹Ğµ 0.3 ÑĞµĞº
    autoClearThread = task.spawn(function()
        while antiBlindEnabled do
            if InstantTransition then
                pcall(function()
                    InstantTransition:Fire(false)
                end)
            end
            task.wait(0.3)
        end
    end)
    
    -- Fullbright + Ğ¾Ñ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ ÑÑ„Ñ„ĞµĞºÑ‚Ğ¾Ğ²
    pcall(function()
        game.Lighting.Brightness = 3
        game.Lighting.GlobalShadows = false
        game.Lighting.Ambient = Color3.fromRGB(180, 180, 180)
    end)
    
    pcall(function()
        for _, obj in game.Lighting:GetDescendants() do
            if obj:IsA("PostEffect") then obj.Enabled = false end
            if obj:IsA("Atmosphere") then obj.Density = 0 end
        end
    end)
    
    Library:Notify("Anti-Shaders & Blind â†’ ON", 4)
end

local function disableAntiBlind()
    antiBlindEnabled = false
    
    if autoClearThread then
        task.cancel(autoClearThread)
        autoClearThread = nil
    end
    
    pcall(function()
        game.Lighting.Brightness = 1
        game.Lighting.GlobalShadows = true
        game.Lighting.Ambient = Color3.fromRGB(0,0,0)
    end)
    
    Library:Notify("Anti-Shaders & Blind â†’ OFF", 4)
end

AntiShaderGroup:AddToggle('AntiBlindToggle', {
    Text = 'Anti Blind / Shaders / Fog',
    Default = false,
    Callback = function(value)
        if value then
            enableAntiBlind()
        else
            disableAntiBlind()
        end
    end
})

AntiShaderGroup:AddButton({
    Text = 'Force Clear Screen',
    Func = function()
        if InstantTransition then
            pcall(function()
                InstantTransition:Fire(false)
            end)
            Library:Notify("Force clear sent", 2)
        else
            Library:Notify("No InstantScreenTransition found", 4)
        end
    end
})
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- Auto Shop Buyer
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local ShopGroup = Tabs.Misc:AddLeftGroupbox('Auto Buy Items')

local selectedItem = "HealingHerb"
local amount = 1
local buying = false

ShopGroup:AddDropdown('ItemToBuy', {
    Text = 'Item',
    Default = 'HealingHerb',
    Values = {
        "HealingHerb", "Bouquet", "Candle", "Flashlight",
        "WoodenStake", "VervainGrenade", "WolfsbaneGrenade",
        "WhiteOakStake", "GoldenArrow", "RedOakStake",
        "IncendiaryArrow", "ExplosiveArrow", "MagicShackles"
    },
    Callback = function(v)
        selectedItem = v
    end
})

ShopGroup:AddSlider('BuyAmount', {
    Text = 'Amount (per click)',
    Default = 1,
    Min = 1,
    Max = 50,
    Rounding = 0,
    Callback = function(v)
        amount = v
    end
})

ShopGroup:AddButton({
    Text = 'Buy Once',
    Func = function()
        local remote = game.ReplicatedStorage.Remotes.GameServices.ToServer.ItemPurchaseRequested_
        for i = 1, amount do
            remote:FireServer("PurchaseTool", selectedItem)
            task.wait(0.06)   -- tiny delay â€“ helps avoid kick / rate-limit
        end
        Library:Notify("Sent Ã—" .. amount .. " â†’ " .. selectedItem, 2.5)
    end
})

ShopGroup:AddToggle('AutoBuyToggle', {
    Text = 'Auto Buy (hold)',
    Default = false,
    Callback = function(v)
        buying = v
        if v then
            Library:Notify("Auto-buy started â†’ " .. selectedItem, 4)
            task.spawn(function()
                while buying do
                    local remote = game.ReplicatedStorage.Remotes.GameServices.ToServer.ItemPurchaseRequested_
                    remote:FireServer("PurchaseTool", selectedItem)
                    task.wait(0.12) -- adjust if getting kicked / flagged
                end
            end)
        else
            Library:Notify("Auto-buy stopped", 3)
        end
    end
})

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- AUTO SOUL COIN FARM + TELEPORT (v3 - TP to Coins)
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local SoulCoinGroup = Tabs.Misc:AddRightGroupbox('Auto Soul Coin Farm + TP')

local autoTPPickup = false
local tpSpeed = 0.3  -- delay between TPs
local pickupRemote = ReplicatedStorage.Remotes.QuestService.ToServer.PickupQuestItem_

local function getAllCoinObjects()
    local coins = {}
    for _, obj in workspace:GetDescendants() do
        if (obj.Name:lower():find("soulcoin") or obj:FindFirstChild("SoulCoin")) and obj:IsA("BasePart") then
            table.insert(coins, obj)
        end
    end
    -- Also check quest item parents (from decomp: objectRef)
    for _, obj in workspace:GetDescendants() do
        if obj.Name:match("[A-Za-z]+") and obj:FindFirstChildWhichIsA("BasePart") then  -- potential spawns
            local coinChild = obj:FindFirstChild("SoulCoin")
            if coinChild then
                table.insert(coins, coinChild)
            end
        end
    end
    return coins
end

local function tpToCoin(coin)
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
    local hrp = LocalPlayer.Character.HumanoidRootPart
    local targetCFrame = coin.CFrame + Vector3.new(0, 3, 0) + Vector3.new(math.random(-2,2), 0, math.random(-2,2))  -- jitter anti-detect
    hrp.CFrame = targetCFrame
end

SoulCoinGroup:AddToggle('AutoTPPickup', {
    Text = 'Auto TP + Pickup Coins',
    Default = false,
    Callback = function(v)
        autoTPPickup = v
        if v then
            Library:Notify('Auto TP Coins â†’ ON | Will teleport & collect all!', 4)
            task.spawn(function()
                while autoTPPickup do
                    local coins = getAllCoinObjects()
                    if #coins > 0 then
                        Library:Notify(#coins .. ' coins found â†’ TPing...', 2)
                        for _, coin in ipairs(coins) do
                            if coin and coin.Parent then
                                tpToCoin(coin)
                                task.wait(0.1)  -- micro delay after TP
                                pcall(function()
                                    pickupRemote:InvokeServer("Ferryman", coin.Name or coin.Parent.Name)
                                end)
                                task.wait(tpSpeed)
                            end
                        end
                    else
                        Library:Notify('No coins found â†’ walk around map', 3)
                    end
                    task.wait(1)  -- respawn check delay
                end
            end)
        else
            Library:Notify('Auto TP Coins â†’ OFF', 3)
        end
    end
})

SoulCoinGroup:AddSlider('TPSpeed', {
    Text = 'TP Delay',
    Default = 0.3,
    Min = 0.1,
    Max = 2,
    Rounding = 2,
    Callback = function(value)
        tpSpeed = value
    end
})

SoulCoinGroup:AddButton({
    Text = 'TP to Nearest Coin (Single)',
    Func = function()
        local coins = getAllCoinObjects()
        if #coins > 0 then
            local nearest = coins[1]  -- or sort by distance
            for _, coin in ipairs(coins) do
                local dist = (LocalPlayer.Character.HumanoidRootPart.Position - coin.Position).Magnitude
                if dist < (LocalPlayer.Character.HumanoidRootPart.Position - nearest.Position).Magnitude then
                    nearest = coin
                end
            end
            tpToCoin(nearest)
            pcall(function()
                pickupRemote:InvokeServer("Ferryman", nearest.Name or nearest.Parent.Name)
            end)
            Library:Notify('TPed to nearest coin & collected!', 3)
        else
            Library:Notify('No coins nearby!', 4)
        end
    end
})

SoulCoinGroup:AddButton({
    Text = 'TP + Pickup ALL Coins Now',
    Func = function()
        local coins = getAllCoinObjects()
        Library:Notify('TPing to ' .. #coins .. ' coins...', 3)
        for _, coin in ipairs(coins) do
            if coin and coin.Parent then
                tpToCoin(coin)
                task.wait(0.15)
                pcall(function()
                    pickupRemote:InvokeServer("Ferryman", coin.Name or coin.Parent.Name)
                end)
                task.wait(0.2)
            end
        end
        Library:Notify('All coins collected! Check backpack.', 4)
    end
})

SoulCoinGroup:AddLabel('â€¢ MF: Waterfall, Mill, Greenhouse, Parkour')


-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- LOW PING HOP: Vampire Legends 2 - Mystic Falls (10561483644)
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- âœ… PUBLIC & ACTIVE (561 players, no restrictions) - Fixes Error 773!
-- Updated Jan 19, 2026 | Server size 30 | Ferryman farms confirmed

local MysticFallsHop = Tabs.Misc:AddLeftGroupbox('Vampire Legends 2 - Mystic Falls Hop')

local maxPingMF = 120  -- UK optimized (40-120ms EU servers)
local placeIdMF = 10561483644  -- Confirmed public PlaceId

local function lowPingHopMF()
    local HttpService = game:GetService("HttpService")
    local TeleportService = game:GetService("TeleportService")
    local currentJobId = game.JobId
    
    Library:Notify('ğŸ” Scanning Mystic Falls servers (low ping <' .. maxPingMF .. 'ms)...', 4)
    
    local servers = {}
    local cursor = nil
    local pages = 0
    
    repeat
        local success, result = pcall(function()
            local url = "https://games.roblox.com/v1/games/" .. placeIdMF .. "/servers/Public?sortOrder=Asc&limit=50"
            if cursor then url = url .. "&cursor=" .. cursor end
            return HttpService:JSONDecode(game:HttpGet(url))
        end)
        
        if success and result and result.data then
            for _, server in result.data do
                local ping = server.ping or 999
                local fill = (server.playing / server.maxPlayers) * 100
                if ping <= maxPingMF and fill <= 85 and server.id ~= currentJobId then  -- <85% full
                    table.insert(servers, {
                        id = server.id,
                        ping = ping,
                        pop = server.playing .. "/" .. server.maxPlayers
                    })
                end
            end
            cursor = result.nextPageCursor
            pages = pages + 1
        end
        task.wait(0.15)
    until not cursor or pages >= 6
    
    if #servers == 0 then
        Library:Notify('No low-ping servers? Rejoining public...', 4)
        TeleportService:Teleport(placeIdMF)
        return
    end
    
    -- Sort: Lowest ping â†’ lowest pop
    table.sort(servers, function(a, b)
        if a.ping ~= b.ping then return a.ping < b.ping end
        return a.pop < b.pop
    end)
    
    local best = servers[1]
    Library:Notify('ğŸ¯ Hopping: ' .. best.ping .. 'ms | ' .. best.pop .. ' players', 3)
    
    pcall(TeleportService.TeleportToPlaceInstance, TeleportService, placeIdMF, best.id, LocalPlayer)
end

MysticFallsHop:AddButton({
    Text = 'ğŸš€ Hop Lowest Ping Mystic Falls',
    Func = lowPingHopMF
})

MysticFallsHop:AddSlider('MaxPingMF', {
    Text = 'Max Ping (ms)',
    Default = 120,
    Min = 40,
    Max = 250,
    Rounding = 0,
    Callback = function(v) maxPingMF = v end
})

MysticFallsHop:AddButton({
    Text = 'Quick Rejoin Mystic Falls',
    Func = function()
        game:GetService("TeleportService"):Teleport(placeIdMF)
    end
})

MysticFallsHop:AddLabel('âœ… Why This Works (No More Error 773):')
MysticFallsHop:AddLabel('â€¢ Public game (561 active, 35K favs, updated 1/12/26)<grok-card data-id="470227" data-type="citation_card" ></grok-card>')
MysticFallsHop:AddLabel('â€¢ Ferryman/Soul Coins farmable (YouTube confirmed)<grok-card data-id="d09d66" data-type="citation_card" ></grok-card><grok-card data-id="64a8da" data-type="citation_card" ></grok-card>')
MysticFallsHop:AddLabel('â€¢ 3AM GMT = 40-90ms EU servers')
MysticFallsHop:AddLabel('After hop: Use Auto TP Coins + Quest Farm!')

-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
-- UI Settings
-- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')
MenuGroup:AddButton('Unload', function() Library:Unload() end)
MenuGroup:AddLabel('Menu Bind'):AddKeyPicker('MenuKeybind', {Default = 'End', NoUI = true})

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({'MenuKeybind'})

ThemeManager:SetFolder('KatyVampHub')
SaveManager:SetFolder('KatyVampHub')
SaveManager:BuildConfigSection(Tabs['UI Settings'])
ThemeManager:ApplyToTab(Tabs['UI Settings'])
SaveManager:LoadAutoloadConfig()

Library:Notify('Hub loaded â€¢ Instant Remote Reset â€¢ Anti-Shaders & Blind â€¢ Safe', 6)
print("Katy Vampire Legends 2 Hub â€¢ FULLY SAFE VERSION LOADED")
